// 04* +Задано уравнение вида q + w = e, q, w, e >= 0.
// Некоторые цифры могут быть заменены знаком вопроса, например 2? + ?5 = 69.
// Требуется восстановить выражение до верного равенства. Предложить хотя бы одно решение или сообщить, что его нет.


//     2? + ?5 = 69
//    34?3 + ? = 34?5 - понятно что w тут равно 2, а вместо первого и последнего ? можно любую цифру поставить
//    По сути мне нужно написать определитель символов +, =, и вопросов.
// В начале нужно удалить все пробелы
//    Зная расположение + и = разбить каждое слагаемое и сумму на отдельный массив символов
//    Тогда посимвольно можно было бы производить операции
//    Алгоритм должен понимать где стоят вопросы и относительно этого отталкиваться о дальнейших действиях.
//    2? + 4? = 68 - тут вместо ? от 0 до 8 получается цифры могут быть
//    ?5 + ?4 = 99 -  - тут вместо ? от 1 до 9 получается цифры могут быть,
//    если 95 + 04 = 99, то вводить 04 не корректно, так можно и 0004 ввести и ???4 получить
//    Считаем, что если есть ? в начале числа то это точно не 0
//    Думаю ещё стоит ограничить, что числа не более чем 3ёхзначные.
//    В таких случаях, можно просто всегда предлагать 1 + какое-то число - нужно ведь хоть одно решение предложить по условию.
//    .
//    99 + 3? = 129 - нужно из суммы, вычитать 99 и сравнивать маску, может ли такое быть
//    99 + 3? = 1234 - так как такого быть не может, потому будем считать, что задаются корректные условия
//    55 + 7?? = 755 - тут будут нули
//    Если вопросы только в одном из чисел, то всё тогда вообще легко
//    55 + 77 = 132
//    ?5 + 7? = ?32 - такое выражение можно распознать подставляя в ?32 цифры от 1 до 9.
//    ?5 + 27? = ?32 - 15 + 270 = 332
//    ?5 + ?? = 132 - 65 + 67 = 132 - вычитать известную цифру и делить на 2
//    ?5 + ?? = 142 - 75 + 67 = 142 - вычитать известную цифру, делить на 2, и добавлять и вычитать по 5 из каждого туда
//    ?? + ?? = 132 - 66 + 66 = 132 - просто делить сумму на 2
//    ?? + ??? = 132 - 32 + 100 = 132
//    ?5 + ?? = 1?2 -
//    ?? + 9? = ??? -
//    ? + 9? = 1?? -
//
//    В общем, поняв что вводимых комбинаций из того сколькозначное числа, в каких местах стоят ?, сколько их, только на слагаемых или на
//    сумме тоже получается комбинаций чрезмерно много, и для каждой нужен свой алгоритм действий.
//    Потому придётся просто перебором цифр вместо ? действовать. Производительность приложения будет низкой, но самой короткой по длине кода.

package Homeworks.HW01;
public class Task04
{
    public static void main(String[] args)
    {
        String line = "2? + ?5 = 69";
        line = line.replace(" ", ""); // обрезаем все пробелы
        char lineChar[] = line.toCharArray(); // переводим в массив символов

       // System.out.printf(" %s ", line);
       int indexOfPlus = line.indexOf("+");
       int indexOfEquals = line.indexOf("=");

//        System.out.printf(" %d \n", indexOfPlus);
//        System.out.printf(" %d \n", indexOfEquals);

        char number01[] = new char[indexOfPlus]; //длина первого числа совпадает с индексом знака "+"
        char number02[] = new char[indexOfEquals - indexOfPlus - 1]; //длина второго числа
        char sumNumbers[] = new char[line.length() - indexOfEquals - 1];

        // System.out.printf("");

        for (int i = 0; i < indexOfPlus; i++)//заполняем массив первого числа
        {
            number01[i] = lineChar[i];
        }

        int counter01 = 0;
        for (int i = indexOfPlus + 1; i < indexOfEquals; i++)//заполняем массив второго числа
        {
            number02[counter01] = lineChar[i];
            ++counter01;
        }
        System.out.printf(" %d \n", counter01);

        int counter02 = 0;
        for (int i = indexOfEquals + 1; i < lineChar.length; i++)//заполняем массив суммы
        {
            sumNumbers[counter02] = lineChar[i];
            ++counter02;
        }
        System.out.printf(" %d \n", indexOfPlus);
        // создать идентичный массив
        // искать в нём символ вопроса
        // в цикле заменить вопрос на 0
        // создать из массива целое число
        // как его создать? может быть в строку преобразовать массив и из него сконвертировать в число,
        // нужно поискать как это в Джаве делается/



        // нужно искать индексы всех вопросов в данном числе-массиве

        int indexesQuestionNumber01[] = new int[number01.length]; // массив с индексами вопросов в первом числе
        int counter03 = 0; // количество вопросов в первом числе

        for (int i = 0; i < number01.length ; i++)
        {
            if (number01[i] == '?')
            {
                indexesQuestionNumber01[counter03] = i; // последовательно в массив вносим индексы того, где стоят вопросы
                counter03++;
            }
        }
        // нужно дальше учесть, что в конце массива нули просто для заполнения, они не указывают на наличие знака вопроса
        // Например тем, что counter03 показывает сколько в слагаемом вопросов
        // и если массив заполнен нулями, и счётчик равен 1, значит на нулевом индексе есть ?
        // если же просто нулями и счётчик равен 0, значит ? нет

        int indexesQuestionNumber02[] = new int[number02.length]; // массив с индексами вопросов во втором числе
        int counter04 = 0; // количество вопросов во втором числе

        for (int i = 0; i < number02.length ; i++) // по-хорошему нужно было бы сделать метод, чтобы не дублировать один код 3 раза,
                                                      // но не знаю как возвращать и массив, и int переменную сразу в одном методе
        {
            if (number02[i] == '?')
            {
                indexesQuestionNumber02[counter04] = i; //
                counter04++;
            }
        }

        int indexesQuestionSumNumbers[] = new int[sumNumbers.length]; // массив с индексами вопросов в сумме
        int counter05 = 0; // количество вопросов в сумме уравнения

        for (int i = 0; i < sumNumbers.length ; i++)
        {
            if (sumNumbers[i] == '?')
            {
                indexesQuestionSumNumbers[counter05] = i; // последовательно в массив вносим индексы того, где стоят вопросы
                counter05++;
            }
        }
        // в данном этапе мы теперь знаем сколько ? в каждом из чисел и на каких индексах они расположены

        int amoutAllQuestion = counter03 + counter04 + counter05; // общее количество вопросов в уравнении

        double combinationQuation = Math.pow(10, amoutAllQuestion) - 1; // получаем максимальное число до которого мы будем перебирать цифры вместо ?
                                                                        // например количество ? в сумме равно 2, то 10^2 - 1 = 99 - 00 до 99 будем перебирать цифры.
        for (int i = 0; i <= combinationQuation; i++)
        {
            String digitsForSelection = Integer.toString(i); // переводим число i в строку

            char arrayDigitsForSelection[] = new char[amoutAllQuestion]; // пустой массив изначально заполнен нулями длиной сколько у нас всего вопросов в уравнении
            int counter06 = arrayDigitsForSelection.length; // счётчик, чтобы идти по массиву

            for (int j = digitsForSelection.length() - 1; j >= 0; j--) // количество проходов зависит от количества разрядов числа i(строки)
            {
                arrayDigitsForSelection[counter06 - 1] = digitsForSelection.charAt(j); // последний индекс = последнему индексу строки, потом предпоследние и так далее,
                                                                                       // пока не закончатся разряды числа i(строки)
                --counter06; // идём по индексам массива с нулями с права на лево, от последнего в сторону нулевого
            }


//            digitsForSelectionArray[0] = 1;
//            digitsForSelectionArray[1] = 1;

             // из строки берём необходимые цифры на замену ?






        }

        // V     нужно перевести число в набор/массив символов
        // V     создать пустой массив заполненный нулями с длиной равной суммарному количеству ?
        // из первого массива символов брать символы с конца и добавлять в конец пустого массива
        // делать именно так нужно, чтобы если число "короче" длины массива, впереди были нули

        // создать копии массивов чисел
        // в этих копиях заменить вопросы на цифры из массива с цифрами для перебора - индексы расположения вопросов мы знаем
        // из этих массивов воссоздать числа
        // проверить равна ли сумма чисел-слагаемых требуемой сумме
        // Если да - это и есть ответ
        // если нет - то следующая итеррация цикла со следующим набором цифр для перебора
        // Если всё перебрали, а ответа нет - решение невозможно.





        char number01Digital[] =  number01.clone();// копия массива первого числа




        // char number01[] = new char[indexOfPlus];




        // System.out.printf("%s", sstr);









    }


}
