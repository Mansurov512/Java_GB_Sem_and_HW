// 04* +Задано уравнение вида q + w = e, q, w, e >= 0.
// Некоторые цифры могут быть заменены знаком вопроса, например 2? + ?5 = 69.
// Требуется восстановить выражение до верного равенства. Предложить хотя бы одно решение или сообщить, что его нет.

//    По ходу написания программы, помимо комментариев к строкам кода записывал размышления/рассуждения.

//    В общем, поняв что вводимых комбинаций из того сколькозначное числа, в каких местах стоят ?, сколько их, только на слагаемых или на
//    сумме тоже получается комбинаций чрезмерно много, и для каждой нужен свой алгоритм действий.
//    Потому придётся просто перебором цифр вместо ? действовать.

package Homeworks.HW01;
import java.util.Arrays;

public class Task04
{
    public static void main(String[] args)
    {
        String line = "2? + ?5 = 69"; //2? + ?5 = 69  ?5 + 7? = ?32  ?5 + ?4 = 99 ?5 + ?? = 142 ?? + ??? = 132
                                           //  ?5 + ?? = 1?2 4??9 + 9?7? = ??32  9? + 9?9? = 10098  ?5 + ????? = 142
        line = line.replace(" ", ""); // обрезаем все пробелы
        char lineChar[] = line.toCharArray(); // переводим в массив символов

        int indexOfPlus = line.indexOf("+"); // индекс +
        int indexOfEquals = line.indexOf("="); // индекс =

        char number01[] = new char[indexOfPlus]; //длина первого числа совпадает с индексом знака "+"
        char number02[] = new char[indexOfEquals - indexOfPlus - 1]; //длина второго числа
        char sumNumbers[] = new char[line.length() - indexOfEquals - 1]; // длина суммы

        for (int i = 0; i < indexOfPlus; i++) //заполняем массив первого числа
        {
            number01[i] = lineChar[i];
        }

        int counter01 = 0;
        for (int i = indexOfPlus + 1; i < indexOfEquals; i++)//заполняем массив второго числа
        {
            number02[counter01] = lineChar[i];
            ++counter01;
        }

        int counter02 = 0;
        for (int i = indexOfEquals + 1; i < lineChar.length; i++)//заполняем массив суммы чисел
        {
            sumNumbers[counter02] = lineChar[i];
            ++counter02;
        }

        int indexesQuestionNumber01[] = new int[number01.length]; // массив с индексами вопросов в первом числе
        int counter03 = 0; // количество вопросов в первом числе

        for (int i = 0; i < number01.length ; i++)
        {
            if (number01[i] == '?')
            {
                indexesQuestionNumber01[counter03] = i; // последовательно в массив вносим индексы того, где стоят вопросы
                counter03++;
            }
        }

        int indexesQuestionNumber02[] = new int[number02.length]; // массив с индексами вопросов во втором числе
        int counter04 = 0; // количество вопросов во втором числе

        for (int i = 0; i < number02.length ; i++) // по-хорошему нужно было бы сделать метод, чтобы не дублировать один код 3 раза,
                                                      // но не знаю как возвращать и массив, и int переменную сразу в одном методе
        {
            if (number02[i] == '?')
            {
                indexesQuestionNumber02[counter04] = i; //
                counter04++;
            }
        }

        int indexesQuestionSumNumbers[] = new int[sumNumbers.length]; // массив с индексами вопросов в сумме
        int counter05 = 0; // количество вопросов в сумме уравнения

        for (int i = 0; i < sumNumbers.length ; i++)
        {
            if (sumNumbers[i] == '?')
            {
                indexesQuestionSumNumbers[counter05] = i; // последовательно в массив вносим индексы того, где стоят вопросы
                counter05++;
            }
        }
        // в данном этапе мы теперь знаем сколько ? в каждом из чисел и на каких индексах они расположены

        int amoutAllQuestion = counter03 + counter04 + counter05; // общее количество ? в уравнении

        double combinationQuation = Math.pow(10, amoutAllQuestion) - 1; // получаем максимальное число до которого мы будем перебирать цифры вместо ?
                                                                        // напр. кол-во ? в сумме равно 2, то 10^2 - 1 = 99 - 00 до 99 будем перебирать цифры.

        for (int i = 0; i <=combinationQuation; i++) // перебираем числа разряды-цифры которого будем подставлять вместо ?
        {
            String digitsForSelection = Integer.toString(i); // переводим число i в строку

            char arrayDigitsForSelection[] = new char[amoutAllQuestion]; // пустой массив длиной сколько у нас всего вопросов в уравнении
            for (int k = 0; k < arrayDigitsForSelection.length; k++)// заполняем массив символами нулей
            {
                arrayDigitsForSelection[k] = '0';
            }

            int counter06 = arrayDigitsForSelection.length; // счётчик, чтобы идти по массиву

            for (int j = digitsForSelection.length() - 1; j >= 0; j--) // количество проходов зависит от количества разрядов числа i(строки)
            {
                arrayDigitsForSelection[counter06 - 1] = digitsForSelection.charAt(j); // последний индекс = последнему индексу строки,
                                                                                       // потом предпоследние и так далее,
                                                                                       // пока не закончатся разряды числа i(строки)

                --counter06; // идём по индексам массива с нулями с права на лево, от последнего в сторону нулевого
            }
            //System.out.println(Arrays.toString(arrayDigitsForSelection)); //для наглядности работы можно оставить

            char number01Digital[] =  number01.clone();// копия массива первого числа
            char number02Digital[] =  number02.clone();// копия массива второго числа
            char sumNumbersDigital[] =  sumNumbers.clone();// копия массива суммы чисел

            int counter07 = 0;
            for (int p01 = 0; p01 < counter03; p01++) // проходим по первому числу столько раз, сколько найдено ?
            {
                number01Digital[indexesQuestionNumber01[p01]] = arrayDigitsForSelection[counter07];// в 1ом числе по индексу расположения ?
                                                                                                   // ставим первые цифры перебора
                ++counter07; // идём по индексам цифр для перебора
            }
            for (int p02 = 0; p02 < counter04; p02++) // проходим по второму числу столько раз, сколько найдено ?
            {
                number02Digital[indexesQuestionNumber02[p02]] = arrayDigitsForSelection[counter07];// в 2ом числе по индексу расположения ?
                                                                                                   // ставим следующие цифры перебора
                ++counter07; // идём по индексам цифр для перебора
            }
            for (int p03 = 0; p03 < counter05; p03++) // проходим по сумме чисел столько раз, сколько найдено ?
            {
                sumNumbersDigital[indexesQuestionSumNumbers[p03]] = arrayDigitsForSelection[counter07];// в сумме чисел по индексу расположения ?
                                                                                                        // ставим оставшиеся цифры перебора
                ++counter07; // идём по индексам цифр для перебора
            }

            String qStr = new String(number01Digital); //массив символов преобразуем в строку
            int q = Integer.parseInt(qStr); //строку же в int число
            String wStr = new String(number02Digital);
            int w = Integer.parseInt(wStr);
            String eStr = new String(sumNumbersDigital);
            int e = Integer.parseInt(eStr);

            if (q + w == e) // проверка решения
            {
                System.out.println(Arrays.toString(arrayDigitsForSelection)); // выводим массив подобранных цифр
                System.out.printf("%d + %d = %d\n", q, w, e); //выводим решение
                break;

            }
            if (i == combinationQuation) // если даже всё выражение состоит из крайнего числа перебора цифр и решения нет, то значит его нет
                                         // а если даже состоит из крайнего, то этот if не будет выполняться
            {
                System.out.printf("Вариантов решения нет.\n");
            }
        }
    }
}

// Размышления - думал в начале, что можно решить задачу не перебором цифр:
//     2? + ?5 = 69
//    34?3 + ? = 34?5 - понятно что w тут равно 2, а вместо первого и последнего ? можно любую цифру поставить
//    По сути мне нужно написать определитель символов +, =, и вопросов.
// В начале нужно удалить все пробелы
//    Зная расположение + и = разбить каждое слагаемое и сумму на отдельный массив символов
//    Тогда посимвольно можно было бы производить операции
//    Алгоритм должен понимать где стоят вопросы и относительно этого отталкиваться о дальнейших действиях.
//    2? + 4? = 68 - тут вместо ? от 0 до 8 получается цифры могут быть
//    ?5 + ?4 = 99 -  - тут вместо ? от 1 до 9 получается цифры могут быть,
//    если 95 + 04 = 99, то вводить 04 не корректно, так можно и 0004 ввести и ???4 получить
//    Считаем, что если есть ? в начале числа то это точно не 0
//    Думаю ещё стоит ограничить, что числа не более чем 3ёхзначные.
//    В таких случаях, можно просто всегда предлагать 1 + какое-то число - нужно ведь хоть одно решение предложить по условию.
//    .
//    99 + 3? = 129 - нужно из суммы, вычитать 99 и сравнивать маску, может ли такое быть
//    99 + 3? = 1234 - так как такого быть не может, потому будем считать, что задаются корректные условия
//    55 + 7?? = 755 - тут будут нули
//    Если вопросы только в одном из чисел, то всё тогда вообще легко
//    55 + 77 = 132
//    ?5 + 7? = ?32 - такое выражение можно распознать подставляя в ?32 цифры от 1 до 9.
//    ?5 + 27? = ?32 - 15 + 270 = 332
//    ?5 + ?? = 132 - 65 + 67 = 132 - вычитать известную цифру и делить на 2
//    ?5 + ?? = 142 - 75 + 67 = 142 - вычитать известную цифру, делить на 2, и добавлять и вычитать по 5 из каждого туда
//    ?? + ?? = 132 - 66 + 66 = 132 - просто делить сумму на 2
//    ?? + ??? = 132 - 32 + 100 = 132
//    ?5 + ?? = 1?2 -
//    ?? + 9? = ??? -
//    ? + 9? = 1?? -

// создать идентичный массив
// искать в нём символ вопроса
// в цикле заменить вопрос на 0
// создать из массива целое число
// как его создать? может быть в строку преобразовать массив и из него сконвертировать в число,
// нужно поискать как это в Джаве делается/

// нужно искать индексы всех вопросов в данном числе-массиве

// нужно дальше учесть, что в конце массива нули просто для заполнения, они не указывают на наличие знака вопроса
// Например тем, что counter03 показывает сколько в слагаемом вопросов
// и если массив заполнен нулями, и счётчик равен 1, значит на нулевом индексе есть ?
// если же просто нулями и счётчик равен 0, значит ? нет

// V     нужно перевести число в набор/массив символов
// V     создать пустой массив заполненный нулями с длиной равной суммарному количеству ?
// V     из первого массива символов брать символы с конца и добавлять в конец пустого массива
// V     делать именно так нужно, чтобы если число "короче" длины массива, впереди были нули

// V     создать копии массивов чисел
// V     в этих копиях заменить вопросы на цифры из массива с цифрами для перебора - индексы расположения вопросов мы знаем
// V     из этих массивов воссоздать числа
// V     проверить равна ли сумма чисел-слагаемых требуемой сумме
// V     Если да - это и есть ответ
// V     если нет - то следующая итеррация цикла со следующим набором цифр для перебора
// V     Если всё перебрали, а ответа нет - решение невозможно.